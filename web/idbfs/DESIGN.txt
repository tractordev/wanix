IDBFS v2 - Optimized IndexedDB Filesystem

IndexedDB database with two object stores:

## Schema

### 1. "metadata" store
Primary key: path

{
    path: string,           // Full path (e.g., "dir/file.txt")
    parent: string,         // Parent directory path (e.g., "dir")
    type: string,           // 'file', 'dir', or 'symlink'
    mode: number,           // POSIX mode bits
    mtime: number,          // Last modification time (unix timestamp)
    atime: number,          // Last access time (unix timestamp)
    size: number,           // File size in bytes
    dataExternal: boolean,  // true if data is in separate 'data' store
    data: Uint8Array|null   // Inline data if < 4KB, null if external
}

Indexes:
- 'parent' index: enables O(log n) child directory queries
- 'type' index: enables filtering by file type
- 'parent_type' compound index: optimized directory listing

### 2. "data" store (for files >= 4KB)
Primary key: path

{
    path: string,           // Full path matching metadata entry
    data: Uint8Array        // File contents
}

## Path Conventions

- Paths do not start with a slash
- Root directory is represented as "."
- All paths are normalized on input

## Performance Features

### Hybrid Storage
- Small files (< 4KB): stored inline with metadata
  - Avoids double lookup for tiny files
  - Most files are small, so this is optimal
  
- Large files (>= 4KB): stored separately in 'data' store
  - Metadata operations don't load large blobs
  - 10-10000x faster metadata operations

### LRU Caching
- Metadata cache: 1000 entries (~100KB memory)
  - Accessed on every operation
  - Very high hit rate for hot paths
  
- Data cache: 10 entries (~varies by file size)
  - Only for large external data blobs
  - Reduces IndexedDB transactions

### Indexed Queries
- Parent index enables O(log n) directory operations
- Eliminates full table scans
- readdir() only loads direct children
- remove() checks emptiness without loading all entries
- 100-1000x faster than scanning all entries

### Batch Transactions
- Directory rename updates all descendants in single transaction
- Reduces transaction overhead from O(n) to O(1)
- Atomic updates for consistency

### Lazy Data Loading
- File handles store only metadata initially
- Data loaded on first read/write operation
- Cached in file handle for subsequent operations
- Written back on close if dirty

## API

interface IDBFS {
    open(path: string): Promise<File>
    create(path: string): Promise<File>
    openfile(path: string, flags: number): Promise<File>
    mkdir(path: string, perm: number): Promise<void>
    symlink(oldpath: string, newpath: string): Promise<void>
    chtimes(path: string, atime: number, mtime: number): Promise<void>
    chmod(path: string, mode: number): Promise<void>
    stat(path: string): Promise<FileInfo>
    truncate(path: string, size: number): Promise<void>
    remove(path: string): Promise<void>
    rename(oldpath: string, newpath: string): Promise<void>
    readlink(path: string): Promise<string>
    readdir(path: string): Promise<FileInfo[]>
}

Symlinks: created with mode 0777 | S_IFLNK, data contains target path
Readlink: returns target path if symlink, error otherwise

interface FileInfo {
    name: string    // basename of the file path
    mode: number    // POSIX mode of the file
    mtime: number   // last modification time in unix time
    atime: number   // last access time in unix time
    size: number    // size of the file in bytes
}

interface File {
    close(): Promise<void>
    stat(): Promise<FileInfo>
    read(buf: Uint8Array): Promise<number>
    write(data: Uint8Array): Promise<number>
    seek(offset: number, whence: number): Promise<number>
    readdir(count: number): Promise<FileInfo[]>
}

## Migration

The database automatically migrates from v1 to v2 schema:
- v1 used single 'fs' store with all data inline
- v2 migration splits large files into 'data' store
- Adds parent and type fields for indexing
- Migration is automatic on first open

## Performance Expectations

Compared to v1 (all-inline storage):

| Operation | v1 (1MB files) | v2 (1MB files) | Improvement |
|-----------|----------------|----------------|-------------|
| stat()    | 1-2ms          | 0.1ms          | 10-20x      |
| readdir() | 500-1000ms*    | 2-5ms          | 100-500x    |
| remove()  | 100-500ms*     | 1-2ms          | 50-500x     |
| chmod()   | 1-2ms          | 0.1ms          | 10-20x      |
| rename()  | 500-2000ms*    | 10-20ms        | 25-200x     |

* For directories with 100 files of 1MB each

Scalability:
- v1: Degrades rapidly with file count and size
- v2: Scales gracefully to thousands of files
